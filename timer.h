/*
TIM1 - Таймер с расширенным управлением - [16bit] - ↑↓ - Любое число до 64К;
TIM2 - Таймер общего назначения - [16bit] - ↑ - Любая степень 2 до 32К;
TIM3 - Таймер общего назначения - [16bit] - ↑ - Любая степень 2 до 32К;
TIM4 - Базовый таймер - [8bit] - ↑ - Любая степень 2 до 128;
TIM5 - Таймер общего назначения - [16bit] - ↑ - Любая степень 2 до 32К;
TIM6 - Базовый таймер - [8bit] - ↑ - Любая степень 2 до 128;
*/

/*
Событие обновления: Переполнение, UG в TIM1_EGR, clock/trigger

Теневой регистр: хранит верхнюю границу счета, которую загружает из TIM1_ARR
Если ARPE = 1, то загрузит только по Событию обновления, если ARPE = 0, то сразу
*/

// =================================================================================================
//                                              TIM1_CNTR
// =================================================================================================
// Хранит значение таймера

// Счетный регистр TIM1 - старший байт (ОБРАЩЕНИЕ К НЕМУ ПЕРВОМУ)
#define TIM1_CNTRH *((unsigned char *)0x525E)
// Счетный регистр TIM1 - младший байт
#define TIM1_CNTRL *((unsigned char *)0x525F)

// =================================================================================================
//                                              TIM1_PSCR
// =================================================================================================
// Предделитель делит входные такты на (свое значение + 1) и полученный такт уже идет на Таймер

// Регистр предделителя TIM1 - старший байт (ОБРАЩЕНИЕ К НЕМУ ПЕРВОМУ)
#define TIM1_PSCRH *((unsigned char *)0x5260)
// Регистр предделителя TIM1 - младший байт 
#define TIM1_PSCRL *((unsigned char *)0x5261)

// =================================================================================================
//                                              TIM1_ARR
// =================================================================================================
// Значение границы счета (До какого считаем), изначально 0xFFFF
// Также является частотой для ШИМ

// Регистр границы счета TIM1 - старший байт (ОБРАЩЕНИЕ К НЕМУ ПЕРВОМУ)
#define TIM1_ARRH *((unsigned char *)0x5262)
// Регистр границы счета TIM1 - младший байт 
#define TIM1_ARRL *((unsigned char *)0x5263)

// =================================================================================================
//                                              TIM1_RCR
// =================================================================================================
// Подсчитывает количество повторений События обновления прежде чем выдать прерывание (пропускает)
// Стандартно — Событие обновления каждый раз 

// Регистр количества повторений
#define TIM1_RCR *((unsigned char *)0x5264)

// =================================================================================================
//                                              TIM1_CR1
// =================================================================================================

// Побитовая структура Регистра управления №1 для TIM1
typedef union DATA_TIM1_CR1 {
    struct {
        // Запускает таймер (установкой 1)
        unsigned char CEN : 1;
        // Запрещает прерывания таймера (События обновления)
        unsigned char UDIS : 1;
        // Выбор режима прерывания (1: только переполнение, 0: переполнение + UG(EGR) + clk/trigger
        unsigned char URS : 1;
        // One Pulse Mode (Считает до переполнения и выключается)
        unsigned char OPM : 1;
        // Направление счета (0: ↑, 1: ↓)
        unsigned char DIR : 1;
        // Режим счета (00: от DIR, 01: ↑ потом ↓(*), 10: ↑(*) потом ↓, 11: ↑(*) потом ↓(*))
        unsigned char CMS : 2;
        // Включение отложенной до События загрузки из TIM1_ARR в Теневой (def: сразу в Теневой)
        unsigned char ARPE : 1;
    };
    // Значение регистра как есть, чистый байт
    unsigned char RAW;
} DATA_TIM1_CR1;

// Регистр управление №1 для TIM1 (Запуск, режимы..)
#define TIM1_CR1 ((DATA_TIM1_CR1 *)0x5250)

// =================================================================================================
//                                              TIM1_CR2
// =================================================================================================

typedef union DATA_TIM1_CR2 {
    struct {
        // Контроль предварительной установки CCiE, CCiNE, CCiP, CCiNP, OCiM
        unsigned char CCPC : 1;
        unsigned char : 1;
        // Если включен CCPC, то идет обновление установкой COMG(0) или COMG/TRGI фронт(1)
        unsigned char COMS : 1;
        unsigned char : 1;
        // Выбор режима Master 
        unsigned char MMS : 3;
        unsigned char : 1;
    };
    // Значение регистра как есть, чистый байт
    unsigned char RAW;
} DATA_TIM1_CR2;

// Регистр управление №2 для TIM1 (Захват/сравнение)
#define TIM1_CR2 ((DATA_TIM1_CR2 *)0x5251)

// =================================================================================================
//                                              TIM1_IER
// =================================================================================================

// Побитовая структура Регистра разрешения прерываний TIM1
typedef union DATA_TIM1_IER {
    struct {
        // Разрешает прерывание по переполнению (Событие обновления)
        unsigned char UIE : 1;
        // Разрешает прерывание по захвату/сравнению на канале 1
        unsigned char CC1IE : 1;
        // Разрешает прерывание по захвату/сравнению на канале 2
        unsigned char CC2IE : 1;
        // Разрешает прерывание по захвату/сравнению на канале 3
        unsigned char CC3IE : 1;
        // Разрешает прерывание по захвату/сравнению на канале 4
        unsigned char CC4IE : 1;
        // Разрешает прерывание по коммутации
        unsigned char COMIE : 1;
        // Разрешает прерывание по событию-триггеру
        unsigned char TIE : 1;
        // Разрешает прерывание по 1 на входе останова
        unsigned char BIE : 1;
    };
    // Значение регистра как есть, чистый байт
    unsigned char RAW;
} DATA_TIM1_IER;

// Регистр разрешения прерываний TIM1
#define TIM1_IER ((DATA_TIM1_IER *)0x5254)

// =================================================================================================
//                                              TIM1_SR1
// =================================================================================================

// Побитовая структура Регистра статуса TIM1
typedef union DATA_TIM1_SR1 {
    struct {
        // Флаг при переполнении(Событие обновления)(если есть разрешение на прерывание)
        unsigned char UIF : 1;
        // Режим сравнения: Флаг при совпадении значения счетчика с TIM1_CCR1
        // Режим захвата: Флаг при появлении импульса на IC1 (При этом значение рег-ра -> TIM1_CCR1)
        unsigned char CC1IF : 1;
        // Режим сравнения: Флаг при совпадении значения счетчика с TIM1_CCR2
        // Режим захвата: Флаг при появлении импульса на IC2 (При этом значение рег-ра -> TIM1_CCR2)
        unsigned char CC2IF : 1;
        // Режим сравнения: Флаг при совпадении значения счетчика с TIM1_CCR3
        // Режим захвата: Флаг при появлении импульса на IC3 (При этом значение рег-ра -> TIM1_CCR3)
        unsigned char CC3IF : 1;
        // Режим сравнения: Флаг при совпадении значения счетчика с TIM1_CCR4
        // Режим захвата: Флаг при появлении импульса на IC4 (При этом значение рег-ра -> TIM1_CCR4)
        unsigned char CC4IF : 1;
        // Флаг прерывания коммутации
        unsigned char COMIF : 1;
        // Флаг прерывания события-триггера
        unsigned char TIF : 1;
        // Флаг при появлении 1 на входе останова (Break)
        unsigned char BIF : 1;
    };
    // Значение регистра как есть, чистый байт
    unsigned char RAW;
} DATA_TIM1_SR1;

// Регистр статуса TIM1 (флаги прерываний)
#define TIM1_SR1 ((DATA_TIM1_SR1 *)0x5255)

// =================================================================================================
//                                              TIM1_SR2
// =================================================================================================

typedef union DATA_TIM1_SR2 {
    struct {
        unsigned char : 1;
        // Только в режиме Захвата: Флаг, Значение счетчика было -> TIM1_CCR1 (CC1IF уже установлен)
        unsigned char CC1OF : 1;
        // Только в режиме Захвата: Флаг, Значение счетчика было -> TIM1_CCR2 (CC2IF уже установлен)
        unsigned char CC2OF : 1;
        // Только в режиме Захвата: Флаг, Значение счетчика было -> TIM1_CCR3 (CC3IF уже установлен)
        unsigned char CC3OF : 1;
        // Только в режиме Захвата: Флаг, Значение счетчика было -> TIM1_CCR4 (CC4IF уже установлен)
        unsigned char CC4OF : 1;
        unsigned char : 3;
    };
    // Значение регистра как есть, чистый байт
    unsigned char RAW;
} DATA_TIM1_SR2;

#define TIM1_SR2 ((DATA_TIM1_SR2 *)0x5256)

// =================================================================================================
//                                              TIM1_EGR
// =================================================================================================

// Побитовая структура Регистра генерации событий TIM1
typedef union DATA_TIM1_EGR {
    struct {
        // Генерирует псевдо-событие переполнения
        unsigned char UG : 1;
        // Генерирует псевдо-событие захвата/сравнения на канале 1
        unsigned char CC1G : 1;
        // Генерирует псевдо-событие захвата/сравнения на канале 2
        unsigned char CC2G : 1;
        // Генерирует псевдо-событие захвата/сравнения на канале 3
        unsigned char CC3G : 1;
        // Генерирует псевдо-событие захвата/сравнения на канале 4
        unsigned char CC4G : 1;
        // Генерирует псевдо-событие коммутации
        unsigned char COMG : 1;
        // Генерирует псевдо-событие триггер-события
        unsigned char TG : 1;
        // Генерирует псевдо-событие 1 на входе останова
        unsigned char BG : 1;
    };
    // Значение регистра как есть, чистый байт
    unsigned char RAW;
} DATA_TIM1_EGR;

// Регистр генерации событий TIM1 (Вызывает псевдо-срабатывания, очищается автоматически)
#define TIM1_EGR ((DATA_TIM1_EGR *)0x5257)